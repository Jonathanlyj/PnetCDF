#
# Copyright (C) 2017, Northwestern University and Argonne National Laboratory
# See COPYRIGHT notice in top-level directory.
#
# $Id$

-----------------------------------------------------------------------------
 Using Burst Buffers in PnetCDF
-----------------------------------------------------------------------------
Burst buffer driver implements a log-based I/O aggregation for write requests.
It is designed to work on a wide range of burst buffer architecture.

-----------------------------------------------------------------------------
 Build PnetCDF with burst buffer feature
-----------------------------------------------------------------------------
Add "--enable-burst-buffering" to your configure command line, e.g.
    ./configure --prefix=/path/to/install --enable-burst-buffering

-----------------------------------------------------------------------------
 Running applications to make use of burst buffers
-----------------------------------------------------------------------------
The burst buffer feature is enabled by setting the PnetCDF I/O hint,
nc_burst_buf, in an MPI info object and passing it to file creation and
opening, for instance by adding the following line in the MPI program.
    MPI_Info_set(info, "nc_burst_buf", "enable");

The hint can also be set through the environment variable PNETCDF_HINTS at the
run time.
    export PNETCDF_HINTS="nc_burst_buf=enable"

-----------------------------------------------------------------------------
 PnetCDF I/O hints for burst buffer controls
-----------------------------------------------------------------------------

Below is a list of supported hints.

Hint key                        Values          Default  Description
---------                       ------          -------  -----------
nc_burst_buf                    enable/disable  disable  Enabling/disabling
                                                         the burst buffering.
nc_burst_buf_dirname            <Valid POSIX    ./       Directory where log
                                 Directory>              files will be stored.
                                                         This is the path burst
                                                         buffer is mounted.
nc_burst_buf_del_on_close       enable/disable  enable   Whether or not the log
                                                         files should be
                                                         deleted after the
                                                         NetCDF file is closed.
                                                         Disabling allows other
                                                         programs to access the
                                                         file.
nc_burst_buf_flush_buffer_size  <integer>       0        Amount of memory per
                                                         MPI process that allows
                                                         PnetCDF to allocate to
                                                         flush the logged data.
                                                         The unit is in bytes.
                                                         0 means unlimited.
                                                         User must guarantee
                                                         that it is larger than
                                                         any individual I/O
                                                         requests.

-----------------------------------------------------------------------------
 Example job script using DataWarp on Cori @NERSC
-----------------------------------------------------------------------------

#!/bin/bash
#SBATCH -p regular
#SBATCH -N 1
#SBATCH -C haswell
#SBATCH -t 00:10:00
#SBATCH -o output.txt
#DW jobdw capacity=1289GiB access_mode=private type=scratch pool=sm_pool
#
export PNETCDF_HINTS="nc_burst_buf=enable;nc_burst_buf_dirname=${DW_JOB_PRIVATE};nc_burst_buf_del_on_close=disable"
srun -n 1 ./a.out

Note the value of hint nc_burst_buf_dirname is set to the DataWarp path
automatically set by the job scheduler SLURM. See more information about the
DataWarp usage in the following URL.
http://www.nersc.gov/users/computational-systems/cori/burst-buffer

-----------------------------------------------------------------------------
 Burst buffering design in PnetCDF
-----------------------------------------------------------------------------

The burst buffer driver is a wrapper driver of the ncmpio (MPI-IO) driver. All
variable write APIs are intercepted and their requests are saved in the burst
buffer. File header I/O proceeds with the ncmpio driver as usual, i.e. directly
accessing to the header stored on the destination file system. When flushing
the data stored in the burst buffer, the driver combines the PnetCDF write
requests into large MPI write requests in hope to achieve a better I/O
performance. When the flushing buffer size is not big enough to accommodate all
data cached in burst buffer, flushing will be done in multiple rounds.

The data stored in the burst buffer is flushed when:
    (1) the NetCDF file is closed,
    (2) there is a variable read request made,
    (3) ncmpi_wait/ncmpi_wait_all is called, or
    (4) ncmpi_flush is called.


-----------------------------------------------------------------------------
 Known issues
-----------------------------------------------------------------------------

1. Burst buffering delays file writes until log-replay time. If an error occurs
   to an individual request, it will be reported at the flushing time and only
   the first error encountered will be reported.

2. Partial flushing is not supported. Any flushing option will flush the entire
   cached data to the destination file system.  Thus, cancelling nonblocking
   write requests may result in getting the error code NC_EFLUSHED, which means
   it is too late to cancel as the requests have been flushed.

3. Sequential consistency is not guaranteed. The burst buffer driver does not
   consider the order the data is cached when flushing.  As a result, if the
   application write to the same file location multiple times without flushing,
   the resulting NetCDF file can contain either value regardless the order the
   write requests were made. User must call ncmpi_flush in order to ensure the
   desired consistency.  For example, after the first write to a variable, a
   flush must be explicitly called before the second write to the same
   variable.

-----------------------------------------------------------------------------
 Log file format
-----------------------------------------------------------------------------

data_log = magic data_list
    magic = 'P' 'n' 'e' 't' 'C' 'D' 'F' '0'
    data_list = [data ...]
        data = <raw binary data form each write request>

metadata_log = header [entry ...]
    header		= magic format endianness is_external num_ranks rank_id entries_offset max_dimension num_entries basename
        magic		= "PnetCDF0"	// case sensitive
        format		= CDF_MAGIC | HDF5_MAGIC | BP_MAGIC
            CDF_MAGIC	= 'C' 'D' 'F' VERSION ZERO
            HDF5_MAGIC	= "\211HDF\r\n\032\n"
            BP_MAGIC	= 'B' 'P' VERSION padding ZERO
            VERSION		= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
        endianness	= BIG_ENDIAN | LITTLE_ENDIAN
            BIG_ENDIAN	= \x00 \x00 \x00 \x00
            LITTLE_ENDIAN	= \x00 \x00 \x00 \x01
        is_external	= TRUE | FALSE		// whether data saved in data file is in external representation
        num_ranks	= MPI_OFFSET	// number of MPI processes
        rank_id		= MPI_OFFSET	// MPI process rank ID
        entries_offset	= MPI_OFFSET	// starting offsset of the first metadata entry (not used)
        max_dimension	= MPI_OFFSET	// max dimensionality amond all entries recorded (not used)
        num_entries	= MPI_OFFSET	// number of write requests
        basename = STRING
    entry		= esize api_kind itype varid ndims data_off data_len starts counts stride
        esize		= MPI_OFFSET		// size of an entry
        api_kind	= NC_API_VARA | NC_API_VARS | INT32 // A positive INT32 indicates varn
            NC_API_VARA = -3
            NC_API_VARS = -4
        itype		= NC_TYPE_TEXT | NC_TYPE_UCHAR | NC_TYPE_SCHAR | NC_TYPE_SHORT | NC_TYPE_USHORT | NC_TYPE_INT | NC_TYPE_UINT | NC_TYPE_FLOAT | NC_TYPE_DOUBLE | NC_TYPE_LONGLONG | NC_TYPE_ULONGLONG // in-memory buffer type
            NC_TYPE_TEXT = 1
            NC_TYPE_UCHAR = 2
            NC_TYPE_SCHAR = 3
            NC_TYPE_SHORT = 4
            NC_TYPE_USHORT = 5
            NC_TYPE_INT = 6
            NC_TYPE_UINT = 7
            NC_TYPE_FLOAT = 8
            NC_TYPE_DOUBLE = 9
            NC_TYPE_LONGLONG = 10
            NC_TYPE_ULONGLONG = 11
        varid		= MPI_OFFSET	// variable ID
        nreqs		= MPI_OFFSET	// number of requests (if > 1, it's for varn APIs)
        ndims		= MPI_OFFSET	// variable's number of dimensions
        data_off	= MPI_OFFSET	// variable's starting offset in data file
        data_len	= MPI_OFFSET	// length of variable occupied in data file
        starts = [start ...]    // N start when api_kind is non-negative N, otherwise, 1 start
            start  = [MPI_OFFSET ...] // ndims of INT64
        counts = [count ...]    // N count when api_kind is non-negative N, otherwise, 1 start
            count  = [MPI_OFFSET ...] // ndims of INT64
        stride = [MPI_OFFSET ...] // ndims of INT64

CHAR		= <8-bit byte>	
ZERO		= \x00 \x00 \x00 \x00	//32-bit zero
INT32		= <32-bit signed integer, native representation>
INT64		= <64-bit signed integer, native representation>
TRUE		= 1		// 32-integer value 1 in native representation
FALSE		= 0		// 32-integer value 0 in native representation
SIZE_T								= <std::size_t defined in c++, Default endian, 2s complement>
INT									= <32 bit integer, Default endian, 2s complement>
MPI_OFFSET							= <MPI_Offset defined in MPICH, Default endian, 2s complement>
STRING = strlen [CHAR ...] padding_4b
    strlen = INT32
    padding_4b	= <0, 1, 2, or 3 bytes to next 4-byte boundary>


